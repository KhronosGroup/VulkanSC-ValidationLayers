/*
 * Copyright (c) 2023-2024 The Khronos Group Inc.
 * Copyright (c) 2023-2024 RasterGrid Kft.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 */

#include "vksc_render_framework.h"
#include "vksc_test_pipeline_cache_helper.h"
#include "vksc_test_dispatch_helper.h"
#include "../../framework/binding.h"

VkSCRenderFramework::~VkSCRenderFramework() {
    if (m_device != nullptr && m_device->handle() != VK_NULL_HANDLE) {
        vksc::DestroyPipelineCache(m_device->handle(), default_pipeline_cache_, nullptr);
    }
}

void VkSCRenderFramework::InitFramework(void *instance_pnext) {
    if (InstanceLayerSupported("VK_LAYER_KHRONOS_device_simulation") && getenv("VKSC_DEVSIM_PROFILE_FILE")) {
        instance_layers_.push_back("VK_LAYER_KHRONOS_device_simulation");
    }

    // Ignore currently unsupported VK_EXT_layer_settings configurations
    m_errorMonitor->SetAllowedFailureMsg("VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT");

    VkRenderFramework::InitFramework(instance_pnext);
}

void VkSCRenderFramework::InitState(VkPhysicalDeviceFeatures *features, void *create_device_pnext,
                                    const VkCommandPoolCreateFlags flags) {
    if (!vku::FindStructInPNextChain<VkDeviceObjectReservationCreateInfo>(create_device_pnext)) {
        // If no object reservation was specified by the test case, then we add the default one
        object_reservation_info_.pNext = create_device_pnext;
        create_device_pnext = &object_reservation_info_;
    }

    auto builder_object_reservation_info = vku::InitStruct<VkDeviceObjectReservationCreateInfo>();
    std::vector<VkPipelineCacheCreateInfo> pipeline_cache_create_infos{};
    if (!pipeline_cache_builders_.empty()) {
        // The test case uses pipeline cache data builders so we have to include the pipeline cache
        // create infos of these at device creation time
        pipeline_cache_create_infos.reserve(pipeline_cache_builders_.size());
        for (const auto &builder : pipeline_cache_builders_) {
            pipeline_cache_create_infos.emplace_back(builder.MakeCreateInfo());
        }
        builder_object_reservation_info.pipelineCacheCreateInfoCount = static_cast<uint32_t>(pipeline_cache_builders_.size());
        builder_object_reservation_info.pPipelineCacheCreateInfos = pipeline_cache_create_infos.data();
        builder_object_reservation_info.pNext = create_device_pnext;
        create_device_pnext = &builder_object_reservation_info;
    }

    VkRenderFramework::InitState(features, create_device_pnext, flags);
}

VkPipelineCache VkSCRenderFramework::GetDefaultPipelineCache() {
    if (default_pipeline_cache_ == VK_NULL_HANDLE) {
        vksc::CreatePipelineCache(m_device->handle(), &vksc::GetDefaultPipelineCacheCreateInfo(), nullptr,
                                  &default_pipeline_cache_);
    }
    return default_pipeline_cache_;
}

VkSCCompatibilityRenderFramework::VkSCCompatibilityRenderFramework()
    : VkSCRenderFramework(), dispatch_helper_(this), shader_modules_(), on_demand_pipeline_caches_() {
    assert(s_instance == nullptr);
    s_instance = this;
}

VkSCCompatibilityRenderFramework::~VkSCCompatibilityRenderFramework() {
    assert(s_instance == this);
    s_instance = nullptr;
}

bool VkSCCompatibilityRenderFramework::GLSLtoSPV(VkPhysicalDeviceLimits const *const device_limits,
                                                 const VkShaderStageFlagBits shader_type, const char *pshader,
                                                 std::vector<uint32_t> &spv, const spv_target_env spv_env) {
    // Force using Vulkan 1.2 environment (SPIR-V 1.5) instead of pre-Vulkan 1.2 in order to avoid glslang
    // generating SPIR-V code that may depend on SPIR-V capabilities not available in Vulkan SC
    // (for example, without this, the ShaderViewportIndexLayerEXT SPIR-V capability, which depends on the
    // unsupported VK_EXT_shader_viewport_index_layer extension would be otherwise generated by glslang
    // instead of the ShaderViewportIndex and/or ShaderLayer SPIR-V capabilities introduced in SPIR-V 1.5
    // and actually supported in Vulkan SC).
    spv_target_env used_spv_env;
    switch (spv_env) {
        case SPV_ENV_VULKAN_1_0:
        case SPV_ENV_VULKAN_1_1:
        case SPV_ENV_VULKAN_1_1_SPIRV_1_4:
            used_spv_env = SPV_ENV_VULKAN_1_2;
            break;
        default:
            used_spv_env = spv_env;
            break;
    }

    return VkSCRenderFramework::GLSLtoSPV(device_limits, shader_type, pshader, spv, used_spv_env);
}

void VkSCCompatibilityRenderFramework::InitFramework(void *instance_pnext) { VkSCRenderFramework::InitFramework(instance_pnext); }

void VkSCCompatibilityRenderFramework::InitState(VkPhysicalDeviceFeatures *features, void *create_device_pnext,
                                                 const VkCommandPoolCreateFlags flags) {
    m_errorMonitor->SetAllowedFailureMsg("UNASSIGNED-PipelineCacheData-SpirvDepValMissingInfo");
    VkSCRenderFramework::InitState(features, create_device_pnext, flags);
}

std::shared_ptr<vksc::PipelineCache> VkSCCompatibilityRenderFramework::CreateOnDemandPipelineCache(
    VkDevice device, const VkPipelineCacheCreateInfo &create_info) {
    m_errorMonitor->SetAllowedFailureMsg("VUID-vkCreatePipelineCache-pCreateInfo-05045");
    m_errorMonitor->SetAllowedFailureMsg("VUID-VkPipelineCacheSafetyCriticalIndexEntry-jsonSize-05081");
    VkPipelineCache pipeline_cache = VK_NULL_HANDLE;
    vksc::CreatePipelineCache(device, &create_info, nullptr, &pipeline_cache);
    return std::make_shared<vksc::PipelineCache>(device, pipeline_cache);
}
