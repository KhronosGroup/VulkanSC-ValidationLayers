/*
 * Copyright (c) 2023-2024 The Khronos Group Inc.
 * Copyright (c) 2023-2024 RasterGrid Kft.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 */

#include "../framework/vksc_layer_validation_tests.h"
#include "../framework/vksc_test_pipeline_helper.h"

// NOTE: The test cases in this file contain tests for implicit VUs that are auto-generated, but
// they deserve their own test cases because these implicit VUs are different in Vulkan SC compared
// to Vulkan.

TEST_F(VkSCLayerTest, ResetCommandPoolReleaseResourcesNotAllowed) {
    TEST_DESCRIPTION("vkResetCommandPool - VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT not allowed");

    RETURN_IF_SKIP(Init());

    auto create_info = vku::InitStruct<VkCommandPoolCreateInfo>();
    vkt::CommandPool cmd_pool(*m_device, create_info);

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkResetCommandPool-flags-zerobitmask");
    vksc::ResetCommandPool(m_device->handle(), cmd_pool.handle(), VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreatePipelinesDerivativeBitNotAllowed) {
    TEST_DESCRIPTION("vkCreate*Pipelines - Vk*PipelineCreateInfo::flags must not contain VK_PIPELINE_CREATE_DERIVATIVE_BIT");
    // NOTE: This test case implicitly tests the removed VUIDs:
    // 00695, 00696, 07984, 07985, 07986 for createComputePipeline
    // 00720, 00721, 07984, 07985, 07986 for createGraphicsPipeline

    RETURN_IF_SKIP(Init());
    InitRenderTarget();

    {
        vksc::ComputePipelineBuilder builder(this);
        builder.Init();
        // VkComputePipelineCreateInfo::flags must not contain VK_PIPELINE_CREATE_DERIVATIVE_BIT
        builder.pipeline_ci.flags = VK_PIPELINE_CREATE_DERIVATIVE_BIT;

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkComputePipelineCreateInfo-None-09497");
        builder.CreatePipeline(*m_device);
        m_errorMonitor->VerifyFound();
    }
    {
        vksc::GraphicsPipelineBuilder builder(this);
        builder.InitVsFs();
        // VkGraphicsPipelineCreateInfo::flags must not contain VK_PIPELINE_CREATE_DERIVATIVE_BIT
        builder.pipeline_ci.flags = VK_PIPELINE_CREATE_DERIVATIVE_BIT;

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkGraphicsPipelineCreateInfo-None-09497");
        builder.CreatePipeline(*m_device);
        m_errorMonitor->VerifyFound();
    }
}

TEST_F(VkSCLayerTest, CreatePipelinesMissingPipelineCache) {
    TEST_DESCRIPTION("vkCreate*Pipelines - pipelineCache must not be VK_NULL_HANDLE");

    RETURN_IF_SKIP(Init());
    InitRenderTarget();

    VkPipeline pipeline = VK_NULL_HANDLE;
    {
        vksc::ComputePipelineBuilder builder(this);
        builder.Init();
        builder.CreatePipeline(*m_device);

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "UNASSIGNED-GeneralParameterError-RequiredHandle");
        // pipelineCache must not be VK_NULL_HANDLE
        vksc::CreateComputePipelines(m_device->handle(), VK_NULL_HANDLE, 1, &builder.pipeline_ci, nullptr, &pipeline);
        m_errorMonitor->VerifyFound();
    }
    {
        vksc::GraphicsPipelineBuilder builder(this);
        builder.InitVsFs();
        builder.CreatePipeline(*m_device);

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "UNASSIGNED-GeneralParameterError-RequiredHandle");
        // pipelineCache must not be VK_NULL_HANDLE
        vksc::CreateGraphicsPipelines(m_device->handle(), VK_NULL_HANDLE, 1, &builder.pipeline_ci, nullptr, &pipeline);
        m_errorMonitor->VerifyFound();
    }
}

TEST_F(VkSCLayerTest, PipelineCacheInitialDataSizeNotZero) {
    TEST_DESCRIPTION("VkPipelineCacheCreateInfo::initialDataSize must not be 0");

    auto create_info = vku::InitStruct<VkPipelineCacheCreateInfo>();
    create_info.flags = VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT | VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT;
    create_info.initialDataSize = 0;

    RETURN_IF_SKIP(InitFramework());

    // Test that error is generated by vkCreateDevice
    auto sc_10_features = vku::InitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info = vku::InitStruct<VkDeviceObjectReservationCreateInfo>(&sc_10_features);
    object_reservation_info.pipelineCacheCreateInfoCount = 1;
    object_reservation_info.pPipelineCacheCreateInfos = &create_info;

    float queue_priority = 1.f;
    auto queue_info = vku::InitStruct<VkDeviceQueueCreateInfo>();
    queue_info.queueCount = 1;
    queue_info.pQueuePriorities = &queue_priority;

    auto device_ci = vku::InitStruct<VkDeviceCreateInfo>(&object_reservation_info);
    device_ci.queueCreateInfoCount = 1;
    device_ci.pQueueCreateInfos = &queue_info;

    VkDevice device = VK_NULL_HANDLE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkPipelineCacheCreateInfo-initialDataSize-arraylength");
    vksc::CreateDevice(gpu(), &device_ci, nullptr, &device);
    m_errorMonitor->VerifyFound();

    RETURN_IF_SKIP(InitState())

    // Test that error is generated by vkCreatePipelineCache
    VkPipelineCache pipeline_cache = VK_NULL_HANDLE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkPipelineCacheCreateInfo-initialDataSize-arraylength");
    vksc::CreatePipelineCache(m_device->handle(), &create_info, nullptr, &pipeline_cache);
    m_errorMonitor->VerifyFound();
}
