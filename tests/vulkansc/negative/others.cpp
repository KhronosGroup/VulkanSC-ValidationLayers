/*
 * Copyright (c) 2023-2025 The Khronos Group Inc.
 * Copyright (c) 2023-2025 RasterGrid Kft.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 */

#include "../framework/vksc_layer_validation_tests.h"


TEST_F(VkSCLayerTest, AllocationCallbacksMustBeNull) {
    TEST_DESCRIPTION("Test that pAllocator is always NULL for Create/Allocate/Destroy commands");

    // NOTE: These VUs are autogenerated so no need to test all cases.
    // This test only serves as a smoke test for a couple of simple cases.

    RETURN_IF_SKIP(Init());

    const VkAllocationCallbacks alloc_cb = {
        nullptr,
        [](void*, size_t size, size_t alignment, VkSystemAllocationScope) -> void* {
#ifdef _MSC_VER
            return _aligned_malloc(size, alignment);
#else
            return std::aligned_alloc(alignment, size);
#endif
        },
        [](void*, void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope) -> void* {
#ifdef _MSC_VER
            _aligned_free(pOriginal);
            return _aligned_malloc(size, alignment);
#else
            std::free(pOriginal);
            return std::aligned_alloc(alignment, size);
#endif
        },
        [](void*, void* pMemory) {
#ifdef _MSC_VER
            _aligned_free(pMemory);
#else
            std::free(pMemory);
#endif
        },
        nullptr,
        nullptr};

    // CreateCommandPool
    {
        VkCommandPool handle = VK_NULL_HANDLE;

        auto mem_reservation_info = vku::InitStruct<VkCommandPoolMemoryReservationCreateInfo>();
        mem_reservation_info.commandPoolReservedSize = 1024 * 1024;
        mem_reservation_info.commandPoolMaxCommandBuffers = 1;

        auto create_info = vku::InitStruct<VkCommandPoolCreateInfo>(&mem_reservation_info);

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkCreateCommandPool-pAllocator-null");
        vksc::CreateCommandPool(m_device->handle(), &create_info, &alloc_cb, &handle);
        m_errorMonitor->VerifyFound();
    }

    // CreateFence / DestroyFence
    {
        VkFence handle = VK_NULL_HANDLE;
        auto create_info = vku::InitStruct<VkFenceCreateInfo>();

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkCreateFence-pAllocator-null");
        vksc::CreateFence(m_device->handle(), &create_info, &alloc_cb, &handle);
        m_errorMonitor->VerifyFound();

        vksc::CreateFence(m_device->handle(), &create_info, nullptr, &handle);

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkDestroyFence-pAllocator-null");
        vksc::DestroyFence(m_device->handle(), handle, &alloc_cb);
        m_errorMonitor->VerifyFound();

        vksc::DestroyFence(m_device->handle(), handle, nullptr);
    }

    // CreateEvent / DestroyEvent
    {
        VkEvent handle = VK_NULL_HANDLE;
        auto create_info = vku::InitStruct<VkEventCreateInfo>();

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkCreateEvent-pAllocator-null");
        vksc::CreateEvent(m_device->handle(), &create_info, &alloc_cb, &handle);
        m_errorMonitor->VerifyFound();

        vksc::CreateEvent(m_device->handle(), &create_info, nullptr, &handle);

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkDestroyEvent-pAllocator-null");
        vksc::DestroyEvent(m_device->handle(), handle, &alloc_cb);
        m_errorMonitor->VerifyFound();

        vksc::DestroyEvent(m_device->handle(), handle, nullptr);
    }

    // CreateSemaphore / DestroySemaphore
    {
        VkSemaphore handle = VK_NULL_HANDLE;
        auto create_info = vku::InitStruct<VkSemaphoreCreateInfo>();

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkCreateSemaphore-pAllocator-null");
        vksc::CreateSemaphore(m_device->handle(), &create_info, &alloc_cb, &handle);
        m_errorMonitor->VerifyFound();

        vksc::CreateSemaphore(m_device->handle(), &create_info, nullptr, &handle);

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkDestroySemaphore-pAllocator-null");
        vksc::DestroySemaphore(m_device->handle(), handle, &alloc_cb);
        m_errorMonitor->VerifyFound();

        vksc::DestroySemaphore(m_device->handle(), handle, nullptr);
    }
}

TEST_F(VkSCLayerTest, CreateInstanceApiVersion) {
    TEST_DESCRIPTION("vkCreateInstance - invalid API version");

    VkInstance instance = VK_NULL_HANDLE;

    auto app_info = vku::InitStruct<VkApplicationInfo>();
    app_info.apiVersion = VK_MAKE_API_VERSION(VKSC_API_VARIANT, 0, 9, 0);

    auto create_info = GetInstanceCreateInfo();
    create_info.pApplicationInfo = &app_info;

    Monitor().SetDesiredFailureMsg(kErrorBit, "VUID-VkApplicationInfo-apiVersion-05021");
    vksc::CreateInstance(&create_info, nullptr, &instance);
    Monitor().VerifyFound();
}

TEST_F(VkSCLayerTest, CreateDescriptorSetLayoutExceededBindingLimit) {
    TEST_DESCRIPTION("vkCreateDescriptorSetLayout - binding index cannot exceed descriptorSetLayoutBindingLimit");

    auto sc_10_features = vku::InitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info1 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info2 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info3 = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info1.pNext = &sc_10_features;
    object_reservation_info2.pNext = &object_reservation_info1;
    object_reservation_info3.pNext = &object_reservation_info2;

    object_reservation_info1.descriptorSetLayoutBindingLimit = 1;
    object_reservation_info2.descriptorSetLayoutBindingLimit = 4;
    object_reservation_info3.descriptorSetLayoutBindingLimit = 3;

    RETURN_IF_SKIP(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info3));

    VkDescriptorSetLayoutBinding bindings[] = {
        {0, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
        {5, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
        {1, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
        {4, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
        {3, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
    };

    auto create_info = vku::InitStruct<VkDescriptorSetLayoutCreateInfo>();
    create_info.bindingCount = sizeof(bindings) / sizeof(bindings[0]);
    create_info.pBindings = &bindings[0];

    VkDescriptorSetLayout layout = VK_NULL_HANDLE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkDescriptorSetLayoutBinding-binding-05012");
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkDescriptorSetLayoutBinding-binding-05012");
    vksc::CreateDescriptorSetLayout(m_device->handle(), &create_info, nullptr, &layout);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreateDescriptorSetLayoutExceededBindingCountLimit) {
    TEST_DESCRIPTION("vkCreateDescriptorSetLayout - binding count cannot exceed descriptorSetLayoutBindingLimit");

    RETURN_IF_SKIP(InitFramework());

    const uint32_t limit = GetVulkanSC10Properties().maxDescriptorSetLayoutBindings;

    auto sc_10_features = vku::InitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info.pNext = &sc_10_features;
    object_reservation_info.descriptorSetLayoutBindingLimit = limit + 1;

    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info));

    std::vector<VkDescriptorSetLayoutBinding> bindings;
    for (uint32_t i = 0; i <= limit; ++i) {
        VkDescriptorSetLayoutBinding binding = {i, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1, VK_SHADER_STAGE_FRAGMENT_BIT};
        bindings.push_back(binding);
    }

    auto create_info = vku::InitStruct<VkDescriptorSetLayoutCreateInfo>();
    create_info.bindingCount = static_cast<uint32_t>(bindings.size());
    create_info.pBindings = bindings.data();

    VkDescriptorSetLayout layout = VK_NULL_HANDLE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkDescriptorSetLayoutCreateInfo-bindingCount-05011");
    vksc::CreateDescriptorSetLayout(m_device->handle(), &create_info, nullptr, &layout);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreateDescriptorSetLayoutExceededImmutableSamplerLimit) {
    TEST_DESCRIPTION("vkCreateDescriptorSetLayout - immutable sampler limit cannot exceed descriptorSetLayoutBindingLimit");

    auto sc_10_features = vku::InitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info1 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info2 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info3 = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info1.pNext = &sc_10_features;
    object_reservation_info2.pNext = &object_reservation_info1;
    object_reservation_info3.pNext = &object_reservation_info2;

    object_reservation_info1.maxImmutableSamplersPerDescriptorSetLayout = 0;
    object_reservation_info2.maxImmutableSamplersPerDescriptorSetLayout = 7;
    object_reservation_info3.maxImmutableSamplersPerDescriptorSetLayout = 5;

    RETURN_IF_SKIP(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info3));

    auto sampler_ci = vku::InitStruct<VkSamplerCreateInfo>();
    vkt::Sampler sampler(*m_device, sampler_ci);

    std::vector<VkSampler> samplers(10, sampler.handle());

    VkDescriptorSetLayoutBinding bindings[] = {
        {0, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 4, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
        {1, VK_DESCRIPTOR_TYPE_SAMPLER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
        {2, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 2, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
        {3, VK_DESCRIPTOR_TYPE_SAMPLER, 3, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
        {4, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 2, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
        // The bindings below will cause the limit to be exceeded
        {5, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
        {6, VK_DESCRIPTOR_TYPE_SAMPLER, 2, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
    };

    auto create_info = vku::InitStruct<VkDescriptorSetLayoutCreateInfo>();
    create_info.bindingCount = sizeof(bindings) / sizeof(bindings[0]);
    create_info.pBindings = &bindings[0];

    VkDescriptorSetLayout layout = VK_NULL_HANDLE;

    // Should fail with all bindings
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkDescriptorSetLayoutCreateInfo-descriptorCount-05071");
    vksc::CreateDescriptorSetLayout(m_device->handle(), &create_info, nullptr, &layout);
    m_errorMonitor->VerifyFound();

    // Should still fail if we exclude the last binding
    create_info.bindingCount--;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkDescriptorSetLayoutCreateInfo-descriptorCount-05071");
    vksc::CreateDescriptorSetLayout(m_device->handle(), &create_info, nullptr, &layout);
    m_errorMonitor->VerifyFound();

    // Should succeed if we exclude the last two bindings
    create_info.bindingCount--;
    vkt::DescriptorSetLayout set_layout(*m_device, create_info);
}

TEST_F(VkSCLayerTest, CreateQueryPoolExceededMaxQueriesPerPool) {
    TEST_DESCRIPTION("vkCreateQueryPool - queryCount cannot exceed max*QueriesPerPool for the corresponding query type");

    AddOptionalExtensions(VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME);
    AddRequiredFeature(vkt::Feature::pipelineStatisticsQuery);
    RETURN_IF_SKIP(InitFramework());

    VkPhysicalDeviceFeatures features{};
    vksc::GetPhysicalDeviceFeatures(Gpu(), &features);
    const auto supports_pipeline_stat_queries = features.pipelineStatisticsQuery;

    auto sc_10_features = vku::InitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info1 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info2 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info3 = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info1.pNext = &sc_10_features;
    object_reservation_info2.pNext = &object_reservation_info1;
    object_reservation_info3.pNext = &object_reservation_info2;

    object_reservation_info1.maxOcclusionQueriesPerPool = 16;
    object_reservation_info2.maxOcclusionQueriesPerPool = 0;
    object_reservation_info3.maxOcclusionQueriesPerPool = 4;

    if (supports_pipeline_stat_queries) {
        object_reservation_info1.maxPipelineStatisticsQueriesPerPool = 6;
        object_reservation_info2.maxPipelineStatisticsQueriesPerPool = 8;
        object_reservation_info3.maxPipelineStatisticsQueriesPerPool = 2;
    }

    object_reservation_info1.maxTimestampQueriesPerPool = 0;
    object_reservation_info2.maxTimestampQueriesPerPool = 10;
    object_reservation_info3.maxTimestampQueriesPerPool = 20;

    bool test_perf_queries = DeviceExtensionSupported(Gpu(), nullptr, VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME);

    if (test_perf_queries) {
        PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR
            vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR =
                (PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)vksc::GetInstanceProcAddr(
                    instance(), "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
        ASSERT_TRUE(vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR != nullptr);

        uint32_t perf_counter_count = 0;
        vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(Gpu(), 0, &perf_counter_count, nullptr, nullptr);
        if (perf_counter_count == 0) {
            test_perf_queries = false;
        }

        // TODO: This is a workaround for a VVL bug related to tracking available performance counters.
        // Unless the application actually queries a counter's data, VVL does not consider it valid.
        // See issue: https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/5894
        std::vector<VkPerformanceCounterKHR> perf_counter(perf_counter_count, vku::InitStruct<VkPerformanceCounterKHR>());
        std::vector<VkPerformanceCounterDescriptionKHR> perf_counter_desc(perf_counter_count,
                                                                          vku::InitStruct<VkPerformanceCounterDescriptionKHR>());
        vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(Gpu(), 0, &perf_counter_count, perf_counter.data(),
                                                                        perf_counter_desc.data());
    }

    auto perf_query_reservation_info1 = vku::InitStruct<VkPerformanceQueryReservationInfoKHR>(&sc_10_features);
    auto perf_query_reservation_info2 = vku::InitStruct<VkPerformanceQueryReservationInfoKHR>(&perf_query_reservation_info1);
    auto perf_query_features = vku::InitStruct<VkPhysicalDevicePerformanceQueryFeaturesKHR>(&perf_query_reservation_info2);
    if (test_perf_queries) {
        perf_query_features.performanceCounterQueryPools = VK_TRUE;
        object_reservation_info1.pNext = &perf_query_features;
        perf_query_reservation_info1.maxPerformanceQueriesPerPool = 1;
        perf_query_reservation_info2.maxPerformanceQueriesPerPool = 3;
    }

    RETURN_IF_SKIP(InitState(nullptr, &object_reservation_info3));

    // Test occlusion queries
    {
        vkt::QueryPool query_pool_obj{};
        VkQueryPool query_pool = VK_NULL_HANDLE;

        auto create_info = vku::InitStruct<VkQueryPoolCreateInfo>();
        create_info.queryType = VK_QUERY_TYPE_OCCLUSION;
        create_info.queryCount = 16;
        query_pool_obj.init(*m_device, create_info);

        create_info.queryCount++;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkQueryPoolCreateInfo-queryType-05046");
        vksc::CreateQueryPool(m_device->handle(), &create_info, nullptr, &query_pool);
        m_errorMonitor->VerifyFound();
    }

    // Test pipeline statistics queries
    if (supports_pipeline_stat_queries) {
        vkt::QueryPool query_pool_obj{};
        VkQueryPool query_pool = VK_NULL_HANDLE;

        auto create_info = vku::InitStruct<VkQueryPoolCreateInfo>();
        create_info.queryType = VK_QUERY_TYPE_PIPELINE_STATISTICS;
        create_info.queryCount = 8;
        create_info.pipelineStatistics = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT;
        query_pool_obj.init(*m_device, create_info);

        create_info.queryCount++;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkQueryPoolCreateInfo-queryType-05047");
        vksc::CreateQueryPool(m_device->handle(), &create_info, nullptr, &query_pool);
        m_errorMonitor->VerifyFound();
    }

    // Test timestamp queries
    {
        vkt::QueryPool query_pool_obj{};
        VkQueryPool query_pool = VK_NULL_HANDLE;

        auto create_info = vku::InitStruct<VkQueryPoolCreateInfo>();
        create_info.queryType = VK_QUERY_TYPE_TIMESTAMP;
        create_info.queryCount = 20;
        query_pool_obj.init(*m_device, create_info);

        create_info.queryCount++;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkQueryPoolCreateInfo-queryType-05048");
        vksc::CreateQueryPool(m_device->handle(), &create_info, nullptr, &query_pool);
        m_errorMonitor->VerifyFound();
    }

    // Test performance queries
    if (test_perf_queries) {
        vkt::QueryPool query_pool_obj{};
        VkQueryPool query_pool = VK_NULL_HANDLE;

        uint32_t perf_counter_index = 0;
        auto perf_info = vku::InitStruct<VkQueryPoolPerformanceCreateInfoKHR>();
        perf_info.counterIndexCount = 1;
        perf_info.pCounterIndices = &perf_counter_index;

        auto create_info = vku::InitStruct<VkQueryPoolCreateInfo>(&perf_info);
        create_info.queryType = VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR;
        create_info.queryCount = 3;
        query_pool_obj.init(*m_device, create_info);

        create_info.queryCount++;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkQueryPoolCreateInfo-queryType-05049");
        vksc::CreateQueryPool(m_device->handle(), &create_info, nullptr, &query_pool);
        m_errorMonitor->VerifyFound();
    }
}

TEST_F(VkSCLayerTest, CreateImageViewExceededMaxMipLevels) {
    TEST_DESCRIPTION("vkCreateImageView - levelCount cannot exceed max[Layered]ImageViewMipLevels");

    auto sc_10_features = vku::InitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info1 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info2 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info3 = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info1.pNext = &sc_10_features;
    object_reservation_info2.pNext = &object_reservation_info1;
    object_reservation_info3.pNext = &object_reservation_info2;

    object_reservation_info1.maxImageViewMipLevels = 1;
    object_reservation_info2.maxImageViewMipLevels = 3;
    object_reservation_info3.maxImageViewMipLevels = 2;

    object_reservation_info1.maxLayeredImageViewMipLevels = 2;
    object_reservation_info2.maxLayeredImageViewMipLevels = 0;
    object_reservation_info3.maxLayeredImageViewMipLevels = 1;

    RETURN_IF_SKIP(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info3));

    VkFormat format = VK_FORMAT_R8G8B8A8_UNORM;
    VkImageUsageFlags usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
    vkt::Image image(*m_device, vkt::Image::ImageCreateInfo2D(128, 128, 6, 4, format, usage, VK_IMAGE_TILING_OPTIMAL));

    auto create_info = vku::InitStruct<VkImageViewCreateInfo>();
    create_info.image = image.handle();
    create_info.viewType = VK_IMAGE_VIEW_TYPE_2D_ARRAY;
    create_info.format = format;
    create_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 2, 3, 2, 1};

    vkt::ImageView image_view_obj(*m_device, create_info);
    VkImageView image_view = VK_NULL_HANDLE;

    create_info.subresourceRange.levelCount++;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05064");
    vksc::CreateImageView(m_device->handle(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.levelCount--;
    create_info.subresourceRange.layerCount++;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05066");
    vksc::CreateImageView(m_device->handle(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.layerCount--;
    create_info.subresourceRange.levelCount = VK_REMAINING_MIP_LEVELS;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05200");
    vksc::CreateImageView(m_device->handle(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.layerCount = VK_REMAINING_ARRAY_LAYERS;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05200");
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05202");
    vksc::CreateImageView(m_device->handle(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.baseMipLevel = 4;
    create_info.subresourceRange.baseArrayLayer = 3;
    vkt::ImageView image_view_obj2(*m_device, create_info);
}

TEST_F(VkSCLayerTest, CreateImageViewExceededMaxArrayLayers) {
    TEST_DESCRIPTION("vkCreateImageView - levelCount cannot exceed maxImageViewArrayLayers");

    auto sc_10_features = vku::InitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info1 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info2 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info3 = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info1.pNext = &sc_10_features;
    object_reservation_info2.pNext = &object_reservation_info1;
    object_reservation_info3.pNext = &object_reservation_info2;

    object_reservation_info1.maxImageViewArrayLayers = 3;
    object_reservation_info2.maxImageViewArrayLayers = 1;
    object_reservation_info3.maxImageViewArrayLayers = 5;

    RETURN_IF_SKIP(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info3));

    VkFormat format = VK_FORMAT_R8G8B8A8_UNORM;
    VkImageUsageFlags usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
    vkt::Image image(*m_device, vkt::Image::ImageCreateInfo2D(128, 128, 6, 8, format, usage, VK_IMAGE_TILING_OPTIMAL));

    auto create_info = vku::InitStruct<VkImageViewCreateInfo>();
    create_info.image = image.handle();
    create_info.viewType = VK_IMAGE_VIEW_TYPE_2D_ARRAY;
    create_info.format = format;
    create_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 1, 3, 2, 5};

    vkt::ImageView image_view_obj(*m_device, create_info);
    VkImageView image_view = VK_NULL_HANDLE;

    create_info.subresourceRange.layerCount++;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05065");
    vksc::CreateImageView(m_device->handle(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.layerCount = VK_REMAINING_ARRAY_LAYERS;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05201");
    vksc::CreateImageView(m_device->handle(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.baseArrayLayer = 5;
    vkt::ImageView image_view_obj2(*m_device, create_info);
}

TEST_F(VkSCLayerTest, CreateBufferUnsupportedFlags) {
    TEST_DESCRIPTION("vkCreateBuffer - sparse create flags are not supported in Vulkan SC");

    RETURN_IF_SKIP(Init());

    VkBuffer buffer = VK_NULL_HANDLE;

    auto create_info = vku::InitStruct<VkBufferCreateInfo>();
    create_info.size = 65536;
    create_info.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;

    std::vector<VkBufferCreateFlagBits> unsupported_flags = {
        VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, VK_BUFFER_CREATE_SPARSE_ALIASED_BIT};

    for (auto flag : unsupported_flags) {
        create_info.flags = flag;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkBufferCreateInfo-flags-05061");
        vksc::CreateBuffer(m_device->handle(), &create_info, nullptr, &buffer);
        m_errorMonitor->VerifyFound();
    }

    create_info.flags = 0;
    for (auto flag : unsupported_flags) {
        create_info.flags |= flag;
    }
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkBufferCreateInfo-flags-05061");
    vksc::CreateBuffer(m_device->handle(), &create_info, nullptr, &buffer);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreateImageUnsupportedFlags) {
    TEST_DESCRIPTION("vkCreateImage - sparse and split-instance bind regions create flags are not supported in Vulkan SC");

    RETURN_IF_SKIP(Init());

    VkImage image = VK_NULL_HANDLE;

    auto create_info = vku::InitStruct<VkImageCreateInfo>();
    create_info.imageType = VK_IMAGE_TYPE_2D;
    create_info.format = VK_FORMAT_R8G8B8A8_UNORM;
    create_info.extent = {16, 16, 1};
    create_info.mipLevels = 2;
    create_info.arrayLayers = 2;
    create_info.samples = VK_SAMPLE_COUNT_1_BIT;
    create_info.tiling = VK_IMAGE_TILING_OPTIMAL;
    create_info.usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;

    std::vector<VkImageCreateFlagBits> unsupported_flags = {
        VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
        VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT};

    for (auto flag : unsupported_flags) {
        create_info.flags = flag;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageCreateInfo-flags-05062");
        vksc::CreateImage(m_device->handle(), &create_info, nullptr, &image);
        m_errorMonitor->VerifyFound();

        create_info.flags |= VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageCreateInfo-flags-05062");
        vksc::CreateImage(m_device->handle(), &create_info, nullptr, &image);
        m_errorMonitor->VerifyFound();
    }

    create_info.flags = 0;
    for (auto flag : unsupported_flags) {
        create_info.flags |= flag;
    }
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageCreateInfo-flags-05062");
    vksc::CreateImage(m_device->handle(), &create_info, nullptr, &image);
    m_errorMonitor->VerifyFound();

    create_info.flags |= VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageCreateInfo-flags-05062");
    vksc::CreateImage(m_device->handle(), &create_info, nullptr, &image);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, BindImageMemorySplitInstanceBindRegionCount) {
    TEST_DESCRIPTION("vkBindImageMemory2 - splitInstanceBindRegionCount must be zero");

    RETURN_IF_SKIP(Init());

    auto create_info = vku::InitStruct<VkImageCreateInfo>();
    create_info.imageType = VK_IMAGE_TYPE_2D;
    create_info.format = VK_FORMAT_R8G8B8A8_UNORM;
    create_info.extent = {16, 16, 1};
    create_info.mipLevels = 1;
    create_info.arrayLayers = 1;
    create_info.samples = VK_SAMPLE_COUNT_1_BIT;
    create_info.tiling = VK_IMAGE_TILING_OPTIMAL;
    create_info.usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;

    vkt::Image image{};
    image.InitNoMemory(*m_device, create_info);

    auto mem_reqs = image.MemoryRequirements();

    auto mem_alloc = vku::InitStruct<VkMemoryAllocateInfo>();
    mem_alloc.memoryTypeIndex = 0;
    mem_alloc.allocationSize = mem_reqs.size;
    const bool memory_found = m_device->Physical().SetMemoryType(mem_reqs.memoryTypeBits, &mem_alloc, 0);
    ASSERT_TRUE(memory_found);

    VkDeviceMemory memory = VK_NULL_HANDLE;
    VkResult result = vk::AllocateMemory(m_device->handle(), &mem_alloc, nullptr, &memory);
    ASSERT_EQ(VK_SUCCESS, result);

    // NOTE: We set up VkBindImageMemoryDeviceGroupInfo in a way that it also tests that none of the removed
    // VUIDs 01633, 01636, 01637, 01638, 01639, 01640, and 01641 are triggered.
    VkRect2D split_instance_bind_region = {{4, 4}, {8, 8}};
    auto device_group_info = vku::InitStruct<VkBindImageMemoryDeviceGroupInfo>();
    device_group_info.splitInstanceBindRegionCount = 1;
    device_group_info.pSplitInstanceBindRegions = &split_instance_bind_region;

    auto bind_info = vku::InitStruct<VkBindImageMemoryInfoKHR>(&device_group_info);
    bind_info.image = image.handle();
    bind_info.memory = memory;
    bind_info.memoryOffset = 0;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkBindImageMemoryDeviceGroupInfo-splitInstanceBindRegionCount-05067");
    vksc::BindImageMemory2(m_device->handle(), 1, &bind_info);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreateFramebufferMaxFramebufferAttachmentsExceeded) {
    TEST_DESCRIPTION("vkCreateFramebuffer - attachmentCount exceeds maxFramebufferAttachments");

    RETURN_IF_SKIP(Init());

    const auto attachment_count = GetVulkanSC10Properties().maxFramebufferAttachments + 1;

    const VkAttachmentDescription attachment{0,
                                             VK_FORMAT_R8G8B8A8_UNORM,
                                             VK_SAMPLE_COUNT_1_BIT,
                                             VK_ATTACHMENT_LOAD_OP_DONT_CARE,
                                             VK_ATTACHMENT_STORE_OP_DONT_CARE,
                                             VK_ATTACHMENT_LOAD_OP_DONT_CARE,
                                             VK_ATTACHMENT_STORE_OP_DONT_CARE,
                                             VK_IMAGE_LAYOUT_UNDEFINED,
                                             VK_IMAGE_LAYOUT_GENERAL};
    const VkSubpassDescription subpass = {};

    auto renderpass_ci = vku::InitStruct<VkRenderPassCreateInfo>();
    renderpass_ci.attachmentCount = 1;
    renderpass_ci.pAttachments = &attachment;
    renderpass_ci.subpassCount = 1;
    renderpass_ci.pSubpasses = &subpass;
    vkt::RenderPass render_pass(*m_device, renderpass_ci);

    std::vector<VkImageView> image_views(attachment_count, VK_NULL_HANDLE);

    auto create_info = vku::InitStruct<VkFramebufferCreateInfo>();
    create_info.renderPass = render_pass.handle();
    create_info.attachmentCount = attachment_count;
    create_info.pAttachments = image_views.data();
    create_info.width = 128;
    create_info.height = 128;
    create_info.layers = 1;

    VkFramebuffer framebuffer = VK_NULL_HANDLE;

    m_errorMonitor->SetAllowedFailureMsg("VUID-VkFramebufferCreateInfo-flags-02778");
    m_errorMonitor->SetAllowedFailureMsg("VUID-VkFramebufferCreateInfo-attachmentCount-00876");
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkFramebufferCreateInfo-attachmentCount-05060");
    vksc::CreateFramebuffer(device(), &create_info, nullptr, &framebuffer);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, GetFaultDataExceedsMaxQueryFaultCount) {
    TEST_DESCRIPTION("vkGetFaultData - pFaultCount exceeds maxQueryFaultCount");

    RETURN_IF_SKIP(Init());

    auto fault_count = GetVulkanSC10Properties().maxQueryFaultCount + 1;

    VkBool32 unrecorded_faults = VK_FALSE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkGetFaultData-pFaultCount-05020");
    vksc::GetFaultData(device(), VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS, &unrecorded_faults, &fault_count, nullptr);
    m_errorMonitor->VerifyFound();
}

static VKAPI_ATTR void VKAPI_CALL FaultCallback(VkBool32, uint32_t, const VkFaultData*) {}

TEST_F(VkSCLayerTest, FaultCallbackInfoFaultCount) {
    TEST_DESCRIPTION("VkFaultCallbackInfo - faultCount is not zero and does not equal maxCallbackFaultCount");

    RETURN_IF_SKIP(InitFramework())

    const auto max_callback_fault_count = GetVulkanSC10Properties().maxCallbackFaultCount;

    auto fault_callback_info = vku::InitStruct<VkFaultCallbackInfo>();
    fault_callback_info.faultCount = max_callback_fault_count == 1 ? 2 : 1;

    std::vector<VkFaultData> fault_data(fault_callback_info.faultCount, vku::InitStruct<VkFaultData>());
    fault_callback_info.pFaults = fault_data.data();
    fault_callback_info.pfnFaultCallback = &FaultCallback;

    auto sc_10_features = vku::InitStruct<VkPhysicalDeviceVulkanSC10Features>(&fault_callback_info);
    auto object_reservation_info = vku::InitStruct<VkDeviceObjectReservationCreateInfo>(&sc_10_features);

    float queue_priority = 1.f;
    auto queue_info = vku::InitStruct<VkDeviceQueueCreateInfo>();
    queue_info.queueCount = 1;
    queue_info.pQueuePriorities = &queue_priority;

    auto device_ci = vku::InitStruct<VkDeviceCreateInfo>(&object_reservation_info);
    device_ci.queueCreateInfoCount = 1;
    device_ci.pQueueCreateInfos = &queue_info;

    VkDevice device = VK_NULL_HANDLE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkFaultCallbackInfo-faultCount-05138");
    vksc::CreateDevice(Gpu(), &device_ci, nullptr, &device);
    m_errorMonitor->VerifyFound();
}
