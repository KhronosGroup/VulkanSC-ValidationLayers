/*
 * Copyright (c) 2023-2023 The Khronos Group Inc.
 * Copyright (c) 2023-2023 RasterGrid Kft.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 */

#include "../framework/vksc_layer_validation_tests.h"

#include <malloc.h>
#include <cstdlib>

TEST_F(VkSCLayerTest, AllocationCallbacksMustBeNull) {
    TEST_DESCRIPTION("Test that pAllocator is always NULL for Create/Allocate/Destroy commands");

    // NOTE: These VUs are autogenerated so no need to test all cases.
    // This test only serves as a smoke test for a couple of simple cases.

    ASSERT_NO_FATAL_FAILURE(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState());

    const VkAllocationCallbacks alloc_cb = {
        nullptr,
        [](void*, size_t size, size_t alignment, VkSystemAllocationScope) -> void* {
#ifdef _MSC_VER
            return _aligned_malloc(size, alignment);
#else
            return std::aligned_alloc(alignment, size);
#endif
        },
        [](void*, void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope) -> void* {
#ifdef _MSC_VER
            _aligned_free(pOriginal);
            return _aligned_malloc(size, alignment);
#else
            std::free(pOriginal);
            return std::aligned_alloc(alignment, size);
#endif
        },
        [](void*, void* pMemory) {
#ifdef _MSC_VER
            _aligned_free(pMemory);
#else
            std::free(pMemory);
#endif
        },
        nullptr,
        nullptr};

    // CreateCommandPool
    {
        VkCommandPool handle = VK_NULL_HANDLE;

        auto mem_reservation_info = LvlInitStruct<VkCommandPoolMemoryReservationCreateInfo>();
        mem_reservation_info.commandPoolReservedSize = 1024 * 1024;
        mem_reservation_info.commandPoolMaxCommandBuffers = 1;

        auto create_info = LvlInitStruct<VkCommandPoolCreateInfo>(&mem_reservation_info);

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkCreateCommandPool-pAllocator-null");
        vksc::CreateCommandPool(m_device->device(), &create_info, &alloc_cb, &handle);
        m_errorMonitor->VerifyFound();
    }

    // CreateFence / DestroyFence
    {
        VkFence handle = VK_NULL_HANDLE;
        auto create_info = LvlInitStruct<VkFenceCreateInfo>();

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkCreateFence-pAllocator-null");
        vksc::CreateFence(m_device->device(), &create_info, &alloc_cb, &handle);
        m_errorMonitor->VerifyFound();

        vksc::CreateFence(m_device->device(), &create_info, nullptr, &handle);

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkDestroyFence-pAllocator-null");
        vksc::DestroyFence(m_device->device(), handle, &alloc_cb);
        m_errorMonitor->VerifyFound();

        vksc::DestroyFence(m_device->device(), handle, nullptr);
    }

    // CreateEvent / DestroyEvent
    {
        VkEvent handle = VK_NULL_HANDLE;
        auto create_info = LvlInitStruct<VkEventCreateInfo>();

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkCreateEvent-pAllocator-null");
        vksc::CreateEvent(m_device->device(), &create_info, &alloc_cb, &handle);
        m_errorMonitor->VerifyFound();

        vksc::CreateEvent(m_device->device(), &create_info, nullptr, &handle);

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkDestroyEvent-pAllocator-null");
        vksc::DestroyEvent(m_device->device(), handle, &alloc_cb);
        m_errorMonitor->VerifyFound();

        vksc::DestroyEvent(m_device->device(), handle, nullptr);
    }

    // CreateSemaphore / DestroySemaphore
    {
        VkSemaphore handle = VK_NULL_HANDLE;
        auto create_info = LvlInitStruct<VkSemaphoreCreateInfo>();

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkCreateSemaphore-pAllocator-null");
        vksc::CreateSemaphore(m_device->device(), &create_info, &alloc_cb, &handle);
        m_errorMonitor->VerifyFound();

        vksc::CreateSemaphore(m_device->device(), &create_info, nullptr, &handle);

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-vkDestroySemaphore-pAllocator-null");
        vksc::DestroySemaphore(m_device->device(), handle, &alloc_cb);
        m_errorMonitor->VerifyFound();

        vksc::DestroySemaphore(m_device->device(), handle, nullptr);
    }
}

TEST_F(VkSCLayerTest, CreateInstanceApiVersion) {
    TEST_DESCRIPTION("vkCreateInstance - invalid API version");

    VkInstance instance = VK_NULL_HANDLE;

    auto app_info = LvlInitStruct<VkApplicationInfo>();
    app_info.apiVersion = VK_MAKE_API_VERSION(VKSC_API_VARIANT, 0, 9, 0);

    auto create_info = GetInstanceCreateInfo();
    create_info.pApplicationInfo = &app_info;

    Monitor().SetDesiredFailureMsg(kErrorBit, "VUID-VkApplicationInfo-apiVersion-05021");
    vksc::CreateInstance(&create_info, nullptr, &instance);
    Monitor().VerifyFound();
}

TEST_F(VkSCLayerTest, CreateCommandPoolMissingMemoryReservationInfo) {
    TEST_DESCRIPTION("vkCreateCommandPool - missing VkCommandPoolMemoryReservationCreateInfo");

    ASSERT_NO_FATAL_FAILURE(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState());

    auto create_info = LvlInitStruct<VkCommandPoolCreateInfo>();
    VkCommandPool cmd_pool = VK_NULL_HANDLE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkCommandPoolCreateInfo-pNext-05002");
    vksc::CreateCommandPool(m_device->device(), &create_info, nullptr, &cmd_pool);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreateCommandPoolInvalidReservedSize) {
    TEST_DESCRIPTION("vkCreateCommandPool - commandPoolReservedSize is zero");

    ASSERT_NO_FATAL_FAILURE(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState());

    auto mem_reservation_info = LvlInitStruct<VkCommandPoolMemoryReservationCreateInfo>();
    mem_reservation_info.commandPoolReservedSize = 0;
    mem_reservation_info.commandPoolMaxCommandBuffers = 1;

    auto create_info = LvlInitStruct<VkCommandPoolCreateInfo>(&mem_reservation_info);
    VkCommandPool cmd_pool = VK_NULL_HANDLE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkCommandPoolMemoryReservationCreateInfo-commandPoolReservedSize-05003");
    vksc::CreateCommandPool(m_device->device(), &create_info, nullptr, &cmd_pool);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreateCommandPoolInvalidMaxCommandBuffers) {
    TEST_DESCRIPTION("vkCreateCommandPool - commandPoolMaxCommandBuffers is zero or greater than maxCommandPoolCommandBuffers");

    ASSERT_NO_FATAL_FAILURE(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState());

    auto mem_reservation_info = LvlInitStruct<VkCommandPoolMemoryReservationCreateInfo>();
    mem_reservation_info.commandPoolReservedSize = 16 * 1024 * 1024;
    mem_reservation_info.commandPoolMaxCommandBuffers = 1;

    auto create_info = LvlInitStruct<VkCommandPoolCreateInfo>(&mem_reservation_info);
    VkCommandPool cmd_pool = VK_NULL_HANDLE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit,
                                         "VUID-VkCommandPoolMemoryReservationCreateInfo-commandPoolMaxCommandBuffers-05004");
    mem_reservation_info.commandPoolMaxCommandBuffers = 0;
    vksc::CreateCommandPool(m_device->device(), &create_info, nullptr, &cmd_pool);
    m_errorMonitor->VerifyFound();

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit,
                                         "VUID-VkCommandPoolMemoryReservationCreateInfo-commandPoolMaxCommandBuffers-05090");
    mem_reservation_info.commandPoolMaxCommandBuffers = GetVulkanSC10Properties(gpu()).maxCommandPoolCommandBuffers + 1;
    vksc::CreateCommandPool(m_device->device(), &create_info, nullptr, &cmd_pool);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, AllocateCommandBuffersExceededMaxCommandBuffers) {
    TEST_DESCRIPTION("vkAllocateCommandBuffers - cannot allocate more command buffers from pool than commandPoolMaxCommandBuffers");

    ASSERT_NO_FATAL_FAILURE(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState());

    const uint32_t max_cmd_buffers = 13;

    auto mem_reservation_info = LvlInitStruct<VkCommandPoolMemoryReservationCreateInfo>();
    mem_reservation_info.commandPoolReservedSize = 16 * 1024 * 1024;
    mem_reservation_info.commandPoolMaxCommandBuffers = max_cmd_buffers;

    auto create_info = LvlInitStruct<VkCommandPoolCreateInfo>(&mem_reservation_info);

    vk_testing::CommandPool cmd_pool(*m_device, create_info);

    auto alloc_info = LvlInitStruct<VkCommandBufferAllocateInfo>();
    alloc_info.commandPool = cmd_pool.handle();

    VkCommandBuffer cmd_buffers[max_cmd_buffers + 1];
    vk_testing::CommandBuffer tmp_cmd_buffers[max_cmd_buffers];
    uint32_t avail_cmd_buffers = max_cmd_buffers;

    // Cannot allocate more than reserved
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkCommandBufferAllocateInfo-commandPool-05006");
    alloc_info.commandBufferCount = max_cmd_buffers + 1;
    vksc::AllocateCommandBuffers(m_device->device(), &alloc_info, cmd_buffers);
    m_errorMonitor->VerifyFound();

    // Allocate some command buffers and try to allocate more than remaining
    for (uint32_t i = 0; i < max_cmd_buffers; ++i) {
        alloc_info.commandBufferCount = 1;
        tmp_cmd_buffers[i].init(*m_device, alloc_info);
        avail_cmd_buffers--;

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkCommandBufferAllocateInfo-commandPool-05006");
        alloc_info.commandBufferCount = avail_cmd_buffers + 1;
        vksc::AllocateCommandBuffers(m_device->device(), &alloc_info, cmd_buffers);
        m_errorMonitor->VerifyFound();
    }

    // Check that freeing command buffers makes exactly as many more available again as expected
    for (uint32_t i = 0; i < max_cmd_buffers / 4; ++i) {
        uint32_t cmd_buffers_to_free = i * 4;
        for (uint32_t j = 0; j < cmd_buffers_to_free; ++j) {
            tmp_cmd_buffers[j].destroy();
            avail_cmd_buffers++;
        }

        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkCommandBufferAllocateInfo-commandPool-05006");
        alloc_info.commandBufferCount = avail_cmd_buffers + 1;
        vksc::AllocateCommandBuffers(m_device->device(), &alloc_info, cmd_buffers);
        m_errorMonitor->VerifyFound();

        for (uint32_t j = 0; j < cmd_buffers_to_free; ++j) {
            alloc_info.commandBufferCount = 1;
            tmp_cmd_buffers[j].init(*m_device, alloc_info);
            avail_cmd_buffers--;
        }
    }
}

TEST_F(VkSCLayerTest, CreateDescriptorSetLayoutExceededBindingLimit) {
    TEST_DESCRIPTION("vkCreateDescriptorSetLayout - binding index cannot exceed descriptorSetLayoutBindingLimit");

    auto sc_10_features = LvlInitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info1 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info2 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info3 = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info1.pNext = &sc_10_features;
    object_reservation_info2.pNext = &object_reservation_info1;
    object_reservation_info3.pNext = &object_reservation_info2;

    object_reservation_info1.descriptorSetLayoutBindingLimit = 1;
    object_reservation_info2.descriptorSetLayoutBindingLimit = 4;
    object_reservation_info3.descriptorSetLayoutBindingLimit = 3;

    ASSERT_NO_FATAL_FAILURE(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info3));

    VkDescriptorSetLayoutBinding bindings[] = {
        {0, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
        {5, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
        {1, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
        {4, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
        {3, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
    };

    auto create_info = LvlInitStruct<VkDescriptorSetLayoutCreateInfo>();
    create_info.bindingCount = sizeof(bindings) / sizeof(bindings[0]);
    create_info.pBindings = &bindings[0];

    VkDescriptorSetLayout layout = VK_NULL_HANDLE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkDescriptorSetLayoutBinding-binding-05012");
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkDescriptorSetLayoutBinding-binding-05012");
    vksc::CreateDescriptorSetLayout(m_device->device(), &create_info, nullptr, &layout);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreateDescriptorSetLayoutExceededBindingCountLimit) {
    TEST_DESCRIPTION("vkCreateDescriptorSetLayout - binding count cannot exceed descriptorSetLayoutBindingLimit");

    ASSERT_NO_FATAL_FAILURE(InitFramework());

    const uint32_t limit = GetVulkanSC10Properties(gpu()).maxDescriptorSetLayoutBindings;

    auto sc_10_features = LvlInitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info.pNext = &sc_10_features;
    object_reservation_info.descriptorSetLayoutBindingLimit = limit + 1;

    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info));

    std::vector<VkDescriptorSetLayoutBinding> bindings;
    for (uint32_t i = 0; i <= limit; ++i) {
        VkDescriptorSetLayoutBinding binding = {i, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1, VK_SHADER_STAGE_FRAGMENT_BIT};
        bindings.push_back(binding);
    }

    auto create_info = LvlInitStruct<VkDescriptorSetLayoutCreateInfo>();
    create_info.bindingCount = static_cast<uint32_t>(bindings.size());
    create_info.pBindings = bindings.data();

    VkDescriptorSetLayout layout = VK_NULL_HANDLE;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkDescriptorSetLayoutCreateInfo-bindingCount-05011");
    vksc::CreateDescriptorSetLayout(m_device->device(), &create_info, nullptr, &layout);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreateDescriptorSetLayoutExceededImmutableSamplerLimit) {
    TEST_DESCRIPTION("vkCreateDescriptorSetLayout - immutable sampler limit cannot exceed descriptorSetLayoutBindingLimit");

    auto sc_10_features = LvlInitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info1 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info2 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info3 = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info1.pNext = &sc_10_features;
    object_reservation_info2.pNext = &object_reservation_info1;
    object_reservation_info3.pNext = &object_reservation_info2;

    object_reservation_info1.maxImmutableSamplersPerDescriptorSetLayout = 0;
    object_reservation_info2.maxImmutableSamplersPerDescriptorSetLayout = 7;
    object_reservation_info3.maxImmutableSamplersPerDescriptorSetLayout = 5;

    ASSERT_NO_FATAL_FAILURE(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info3));

    auto sampler_ci = LvlInitStruct<VkSamplerCreateInfo>();
    vk_testing::Sampler sampler(*m_device, sampler_ci);

    std::vector<VkSampler> samplers(10, sampler.handle());

    VkDescriptorSetLayoutBinding bindings[] = {
        {0, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 4, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
        {1, VK_DESCRIPTOR_TYPE_SAMPLER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
        {2, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 2, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
        {3, VK_DESCRIPTOR_TYPE_SAMPLER, 3, VK_SHADER_STAGE_FRAGMENT_BIT, nullptr},
        {4, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 2, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
        // The bindings below will cause the limit to be exceeded
        {5, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
        {6, VK_DESCRIPTOR_TYPE_SAMPLER, 2, VK_SHADER_STAGE_FRAGMENT_BIT, samplers.data()},
    };

    auto create_info = LvlInitStruct<VkDescriptorSetLayoutCreateInfo>();
    create_info.bindingCount = sizeof(bindings) / sizeof(bindings[0]);
    create_info.pBindings = &bindings[0];

    VkDescriptorSetLayout layout = VK_NULL_HANDLE;

    // Should fail with all bindings
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkDescriptorSetLayoutCreateInfo-descriptorCount-05071");
    vksc::CreateDescriptorSetLayout(m_device->device(), &create_info, nullptr, &layout);
    m_errorMonitor->VerifyFound();

    // Should still fail if we exclude the last binding
    create_info.bindingCount--;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkDescriptorSetLayoutCreateInfo-descriptorCount-05071");
    vksc::CreateDescriptorSetLayout(m_device->device(), &create_info, nullptr, &layout);
    m_errorMonitor->VerifyFound();

    // Should succeed if we exclude the last two bindings
    create_info.bindingCount--;
    vk_testing::DescriptorSetLayout set_layout(*m_device, create_info);
}

TEST_F(VkSCLayerTest, CreateQueryPoolExceededMaxQueriesPerPool) {
    TEST_DESCRIPTION("vkCreateQueryPool - queryCount cannot exceed max*QueriesPerPool for the corresponding query type");

    AddOptionalExtensions(VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME);
    ASSERT_NO_FATAL_FAILURE(InitFramework());

    auto sc_10_features = LvlInitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info1 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info2 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info3 = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info1.pNext = &sc_10_features;
    object_reservation_info2.pNext = &object_reservation_info1;
    object_reservation_info3.pNext = &object_reservation_info2;

    object_reservation_info1.maxOcclusionQueriesPerPool = 16;
    object_reservation_info2.maxOcclusionQueriesPerPool = 0;
    object_reservation_info3.maxOcclusionQueriesPerPool = 4;

    object_reservation_info1.maxPipelineStatisticsQueriesPerPool = 6;
    object_reservation_info2.maxPipelineStatisticsQueriesPerPool = 8;
    object_reservation_info3.maxPipelineStatisticsQueriesPerPool = 2;

    object_reservation_info1.maxTimestampQueriesPerPool = 0;
    object_reservation_info2.maxTimestampQueriesPerPool = 10;
    object_reservation_info3.maxTimestampQueriesPerPool = 20;

    bool test_perf_queries = DeviceExtensionSupported(gpu(), nullptr, VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME);

    if (test_perf_queries) {
        PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR
            vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR =
                (PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)vksc::GetInstanceProcAddr(
                    instance(), "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
        ASSERT_TRUE(vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR != nullptr);

        uint32_t perf_counter_count = 0;
        vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(gpu(), 0, &perf_counter_count, nullptr, nullptr);
        if (perf_counter_count == 0) {
            test_perf_queries = false;
        }

        // TODO: This is a workaround for a VVL bug related to tracking available performance counters.
        // Unless the application actually queries a counter's data, VVL does not consider it valid.
        // See issue: https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/5894
        std::vector<VkPerformanceCounterKHR> perf_counter(perf_counter_count, LvlInitStruct<VkPerformanceCounterKHR>());
        std::vector<VkPerformanceCounterDescriptionKHR> perf_counter_desc(perf_counter_count,
                                                                          LvlInitStruct<VkPerformanceCounterDescriptionKHR>());
        vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(gpu(), 0, &perf_counter_count, perf_counter.data(),
                                                                        perf_counter_desc.data());
    }

    auto perf_query_reservation_info1 = LvlInitStruct<VkPerformanceQueryReservationInfoKHR>(&sc_10_features);
    auto perf_query_reservation_info2 = LvlInitStruct<VkPerformanceQueryReservationInfoKHR>(&perf_query_reservation_info1);
    auto perf_query_features = LvlInitStruct<VkPhysicalDevicePerformanceQueryFeaturesKHR>(&perf_query_reservation_info2);
    if (test_perf_queries) {
        perf_query_features.performanceCounterQueryPools = VK_TRUE;
        object_reservation_info1.pNext = &perf_query_features;
        perf_query_reservation_info1.maxPerformanceQueriesPerPool = 1;
        perf_query_reservation_info2.maxPerformanceQueriesPerPool = 3;
    }

    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info3));

    // Test occlusion queries
    {
        vk_testing::QueryPool query_pool_obj{};
        VkQueryPool query_pool = VK_NULL_HANDLE;

        auto create_info = LvlInitStruct<VkQueryPoolCreateInfo>();
        create_info.queryType = VK_QUERY_TYPE_OCCLUSION;
        create_info.queryCount = 16;
        query_pool_obj.init(*m_device, create_info);

        create_info.queryCount++;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkQueryPoolCreateInfo-queryType-05046");
        vksc::CreateQueryPool(m_device->device(), &create_info, nullptr, &query_pool);
        m_errorMonitor->VerifyFound();
    }

    // Test pipeline statistics queries
    {
        vk_testing::QueryPool query_pool_obj{};
        VkQueryPool query_pool = VK_NULL_HANDLE;

        auto create_info = LvlInitStruct<VkQueryPoolCreateInfo>();
        create_info.queryType = VK_QUERY_TYPE_PIPELINE_STATISTICS;
        create_info.queryCount = 8;
        create_info.pipelineStatistics = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT;
        query_pool_obj.init(*m_device, create_info);

        create_info.queryCount++;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkQueryPoolCreateInfo-queryType-05047");
        vksc::CreateQueryPool(m_device->device(), &create_info, nullptr, &query_pool);
        m_errorMonitor->VerifyFound();
    }

    // Test timestamp queries
    {
        vk_testing::QueryPool query_pool_obj{};
        VkQueryPool query_pool = VK_NULL_HANDLE;

        auto create_info = LvlInitStruct<VkQueryPoolCreateInfo>();
        create_info.queryType = VK_QUERY_TYPE_TIMESTAMP;
        create_info.queryCount = 20;
        query_pool_obj.init(*m_device, create_info);

        create_info.queryCount++;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkQueryPoolCreateInfo-queryType-05048");
        vksc::CreateQueryPool(m_device->device(), &create_info, nullptr, &query_pool);
        m_errorMonitor->VerifyFound();
    }

    // Test performance queries
    if (test_perf_queries) {
        vk_testing::QueryPool query_pool_obj{};
        VkQueryPool query_pool = VK_NULL_HANDLE;

        uint32_t perf_counter_index = 0;
        auto perf_info = LvlInitStruct<VkQueryPoolPerformanceCreateInfoKHR>();
        perf_info.counterIndexCount = 1;
        perf_info.pCounterIndices = &perf_counter_index;

        auto create_info = LvlInitStruct<VkQueryPoolCreateInfo>(&perf_info);
        create_info.queryType = VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR;
        create_info.queryCount = 3;
        query_pool_obj.init(*m_device, create_info);

        create_info.queryCount++;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkQueryPoolCreateInfo-queryType-05049");
        vksc::CreateQueryPool(m_device->device(), &create_info, nullptr, &query_pool);
        m_errorMonitor->VerifyFound();
    }
}

TEST_F(VkSCLayerTest, CreateImageViewExceededMaxMipLevels) {
    TEST_DESCRIPTION("vkCreateImageView - levelCount cannot exceed max[Layered]ImageViewMipLevels");

    auto sc_10_features = LvlInitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info1 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info2 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info3 = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info1.pNext = &sc_10_features;
    object_reservation_info2.pNext = &object_reservation_info1;
    object_reservation_info3.pNext = &object_reservation_info2;

    object_reservation_info1.maxImageViewMipLevels = 1;
    object_reservation_info2.maxImageViewMipLevels = 3;
    object_reservation_info3.maxImageViewMipLevels = 2;

    object_reservation_info1.maxLayeredImageViewMipLevels = 2;
    object_reservation_info2.maxLayeredImageViewMipLevels = 0;
    object_reservation_info3.maxLayeredImageViewMipLevels = 1;

    ASSERT_NO_FATAL_FAILURE(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info3));

    VkImageObj image(m_device);
    VkFormat format = VK_FORMAT_R8G8B8A8_UNORM;
    VkImageUsageFlags usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
    image.Init(VkImageObj::ImageCreateInfo2D(128, 128, 6, 4, format, usage, VK_IMAGE_TILING_OPTIMAL));

    auto create_info = LvlInitStruct<VkImageViewCreateInfo>();
    create_info.image = image.handle();
    create_info.viewType = VK_IMAGE_VIEW_TYPE_2D_ARRAY;
    create_info.format = format;
    create_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 2, 3, 2, 1};

    vk_testing::ImageView image_view_obj(*m_device, create_info);
    VkImageView image_view = VK_NULL_HANDLE;

    create_info.subresourceRange.levelCount++;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05064");
    vksc::CreateImageView(m_device->device(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.levelCount--;
    create_info.subresourceRange.layerCount++;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05066");
    vksc::CreateImageView(m_device->device(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.layerCount--;
    create_info.subresourceRange.levelCount = VK_REMAINING_MIP_LEVELS;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05064");
    vksc::CreateImageView(m_device->device(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.layerCount = VK_REMAINING_ARRAY_LAYERS;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05064");
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05066");
    vksc::CreateImageView(m_device->device(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.baseMipLevel = 4;
    create_info.subresourceRange.baseArrayLayer = 3;
    vk_testing::ImageView image_view_obj2(*m_device, create_info);
}

TEST_F(VkSCLayerTest, CreateImageViewExceededMaxArrayLayers) {
    TEST_DESCRIPTION("vkCreateImageView - levelCount cannot exceed maxImageViewArrayLayers");

    auto sc_10_features = LvlInitStruct<VkPhysicalDeviceVulkanSC10Features>();
    auto object_reservation_info1 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info2 = vksc::GetDefaultObjectReservationCreateInfo();
    auto object_reservation_info3 = vksc::GetDefaultObjectReservationCreateInfo();

    object_reservation_info1.pNext = &sc_10_features;
    object_reservation_info2.pNext = &object_reservation_info1;
    object_reservation_info3.pNext = &object_reservation_info2;

    object_reservation_info1.maxImageViewArrayLayers = 3;
    object_reservation_info2.maxImageViewArrayLayers = 1;
    object_reservation_info3.maxImageViewArrayLayers = 5;

    ASSERT_NO_FATAL_FAILURE(InitFramework());
    ASSERT_NO_FATAL_FAILURE(InitState(nullptr, &object_reservation_info3));

    VkImageObj image(m_device);
    VkFormat format = VK_FORMAT_R8G8B8A8_UNORM;
    VkImageUsageFlags usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
    image.Init(VkImageObj::ImageCreateInfo2D(128, 128, 6, 8, format, usage, VK_IMAGE_TILING_OPTIMAL));

    auto create_info = LvlInitStruct<VkImageViewCreateInfo>();
    create_info.image = image.handle();
    create_info.viewType = VK_IMAGE_VIEW_TYPE_2D_ARRAY;
    create_info.format = format;
    create_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 1, 3, 2, 5};

    vk_testing::ImageView image_view_obj(*m_device, create_info);
    VkImageView image_view = VK_NULL_HANDLE;

    create_info.subresourceRange.layerCount++;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05065");
    vksc::CreateImageView(m_device->device(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.layerCount = VK_REMAINING_ARRAY_LAYERS;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageViewCreateInfo-subresourceRange-05065");
    vksc::CreateImageView(m_device->device(), &create_info, nullptr, &image_view);
    m_errorMonitor->VerifyFound();

    create_info.subresourceRange.baseArrayLayer = 5;
    vk_testing::ImageView image_view_obj2(*m_device, create_info);
}

TEST_F(VkSCLayerTest, CreateBufferUnsupportedFlags) {
    TEST_DESCRIPTION("vkCreateBuffer - sparse create flags are not supported in Vulkan SC");

    ASSERT_NO_FATAL_FAILURE(Init());

    VkBuffer buffer = VK_NULL_HANDLE;

    auto create_info = LvlInitStruct<VkBufferCreateInfo>();
    create_info.size = 65536;
    create_info.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;

    std::vector<VkBufferCreateFlagBits> unsupported_flags = {
        VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, VK_BUFFER_CREATE_SPARSE_ALIASED_BIT};

    for (auto flag : unsupported_flags) {
        create_info.flags = flag;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkBufferCreateInfo-flags-05061");
        vksc::CreateBuffer(m_device->handle(), &create_info, nullptr, &buffer);
        m_errorMonitor->VerifyFound();
    }

    create_info.flags = 0;
    for (auto flag : unsupported_flags) {
        create_info.flags |= flag;
    }
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkBufferCreateInfo-flags-05061");
    vksc::CreateBuffer(m_device->handle(), &create_info, nullptr, &buffer);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreateImageUnsupportedFlags) {
    TEST_DESCRIPTION("vkCreateImage - sparse and split-instance bind regions create flags are not supported in Vulkan SC");

    ASSERT_NO_FATAL_FAILURE(Init());

    VkImage image = VK_NULL_HANDLE;

    auto create_info = LvlInitStruct<VkImageCreateInfo>();
    create_info.imageType = VK_IMAGE_TYPE_2D;
    create_info.format = VK_FORMAT_R8G8B8A8_UNORM;
    create_info.extent = {16, 16, 1};
    create_info.mipLevels = 2;
    create_info.arrayLayers = 2;
    create_info.samples = VK_SAMPLE_COUNT_1_BIT;
    create_info.tiling = VK_IMAGE_TILING_OPTIMAL;
    create_info.usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;

    std::vector<VkImageCreateFlagBits> unsupported_flags = {
        VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
        VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT};

    for (auto flag : unsupported_flags) {
        create_info.flags = flag;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageCreateInfo-flags-05062");
        vksc::CreateImage(m_device->handle(), &create_info, nullptr, &image);
        m_errorMonitor->VerifyFound();

        create_info.flags |= VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
        m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageCreateInfo-flags-05062");
        vksc::CreateImage(m_device->handle(), &create_info, nullptr, &image);
        m_errorMonitor->VerifyFound();
    }

    create_info.flags = 0;
    for (auto flag : unsupported_flags) {
        create_info.flags |= flag;
    }
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageCreateInfo-flags-05062");
    vksc::CreateImage(m_device->handle(), &create_info, nullptr, &image);
    m_errorMonitor->VerifyFound();

    create_info.flags |= VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkImageCreateInfo-flags-05062");
    vksc::CreateImage(m_device->handle(), &create_info, nullptr, &image);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, BindImageMemorySplitInstanceBindRegionCount) {
    TEST_DESCRIPTION("vkBindImageMemory2 - splitInstanceBindRegionCount must be zero");

    ASSERT_NO_FATAL_FAILURE(Init());

    auto create_info = LvlInitStruct<VkImageCreateInfo>();
    create_info.imageType = VK_IMAGE_TYPE_2D;
    create_info.format = VK_FORMAT_R8G8B8A8_UNORM;
    create_info.extent = {16, 16, 1};
    create_info.mipLevels = 1;
    create_info.arrayLayers = 1;
    create_info.samples = VK_SAMPLE_COUNT_1_BIT;
    create_info.tiling = VK_IMAGE_TILING_OPTIMAL;
    create_info.usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;

    VkImageObj image(m_device);
    image.init_no_mem(*m_device, create_info);

    auto mem_reqs = image.memory_requirements();

    auto mem_alloc = LvlInitStruct<VkMemoryAllocateInfo>();
    mem_alloc.memoryTypeIndex = 0;
    mem_alloc.allocationSize = mem_reqs.size;
    const bool memory_found = m_device->phy().set_memory_type(mem_reqs.memoryTypeBits, &mem_alloc, 0);
    ASSERT_TRUE(memory_found);

    VkDeviceMemory memory = VK_NULL_HANDLE;
    VkResult result = vk::AllocateMemory(m_device->device(), &mem_alloc, nullptr, &memory);
    ASSERT_VK_SUCCESS(result);

    // NOTE: We set up VkBindImageMemoryDeviceGroupInfo in a way that it also tests that none of the removed
    // VUIDs 01633, 01636, 01637, 01638, 01639, 01640, and 01641 are triggered.
    VkRect2D split_instance_bind_region = {{4, 4}, {8, 8}};
    auto device_group_info = LvlInitStruct<VkBindImageMemoryDeviceGroupInfo>();
    device_group_info.splitInstanceBindRegionCount = 1;
    device_group_info.pSplitInstanceBindRegions = &split_instance_bind_region;

    auto bind_info = LvlInitStruct<VkBindImageMemoryInfoKHR>(&device_group_info);
    bind_info.image = image.handle();
    bind_info.memory = memory;
    bind_info.memoryOffset = 0;

    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkBindImageMemoryDeviceGroupInfo-splitInstanceBindRegionCount-05067");
    vksc::BindImageMemory2(m_device->handle(), 1, &bind_info);
    m_errorMonitor->VerifyFound();
}

TEST_F(VkSCLayerTest, CreateFramebufferMaxFramebufferAttachmentsExceeded) {
    TEST_DESCRIPTION("vkCreateFramebuffer - attachmentCount exceeds maxFramebufferAttachments");

    ASSERT_NO_FATAL_FAILURE(Init());

    const auto attachment_count = GetVulkanSC10Properties(gpu()).maxFramebufferAttachments + 1;

    const VkAttachmentDescription attachment{0,
                                             VK_FORMAT_R8G8B8A8_UNORM,
                                             VK_SAMPLE_COUNT_1_BIT,
                                             VK_ATTACHMENT_LOAD_OP_DONT_CARE,
                                             VK_ATTACHMENT_STORE_OP_DONT_CARE,
                                             VK_ATTACHMENT_LOAD_OP_DONT_CARE,
                                             VK_ATTACHMENT_STORE_OP_DONT_CARE,
                                             VK_IMAGE_LAYOUT_UNDEFINED,
                                             VK_IMAGE_LAYOUT_GENERAL};
    const VkSubpassDescription subpass = {};

    auto renderpass_ci = LvlInitStruct<VkRenderPassCreateInfo>();
    renderpass_ci.attachmentCount = 1;
    renderpass_ci.pAttachments = &attachment;
    renderpass_ci.subpassCount = 1;
    renderpass_ci.pSubpasses = &subpass;
    vk_testing::RenderPass render_pass(*m_device, renderpass_ci);

    std::vector<VkImageView> image_views(attachment_count, VK_NULL_HANDLE);

    auto create_info = LvlInitStruct<VkFramebufferCreateInfo>();
    create_info.renderPass = render_pass.handle();
    create_info.attachmentCount = attachment_count;
    create_info.pAttachments = image_views.data();
    create_info.width = 128;
    create_info.height = 128;
    create_info.layers = 1;

    VkFramebuffer framebuffer = VK_NULL_HANDLE;

    m_errorMonitor->SetAllowedFailureMsg("VUID-VkFramebufferCreateInfo-attachmentCount-00876");
    m_errorMonitor->SetDesiredFailureMsg(kErrorBit, "VUID-VkFramebufferCreateInfo-attachmentCount-05060");
    vksc::CreateFramebuffer(device(), &create_info, nullptr, &framebuffer);
    m_errorMonitor->VerifyFound();
}
